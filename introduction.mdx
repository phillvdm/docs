---
title: Introduction
description: "SQLite is the ideal in-app database for web, mobile, and desktop applications. However, there is no standardized implementation for higher-level languages. This manifesto outlines the challenges, common issues, and guiding principles for effective SQLite integration."
---

<img 
  height="200" 
  noZoom 
  src="docs/images/feather.jpg"
  alt="Feather illustration"
/>

## Background
SQLite is a lightweight, self-contained, and efficient database engine. However, the SQLite project itself provides only the core C library. Developers integrating SQLite into higher-level languages must account for multiple layers:
1. SQLite Build – Precompiled binaries for different platforms, often with custom compiler flags.
2. Low-Level Bindings – Language-specific APIs to interface with the SQLite C library.
3. High-Level Bindings – Wrappers for ease of use, concurrency handling, and additional features.
4. ORM (Optional) – Object-relational mapping for abstracting SQL queries.

Since these layers can be implemented in different ways, SQLite libraries vary widely in quality and capability.

### Common issues

#### Layer 1: SQLite build
- Often bundled within Layer 2, making customization difficult.
- Compile options vary, leading to inconsistencies across platforms.
- Some builds lack useful extensions or enable them inconsistently.
- Not always compiled with extension loading enabled.
- Updates can lag behind the official SQLite releases.

#### Layer 2: Low-level bindings
- Frequently bundles the SQLite build, limiting configuration options.
- May require extensive effort to replace or customize the SQLite build.
- Limited transaction APIs in some languages.
- In cross-platform SDKs (Flutter, React Native, etc.), bindings often route through native code (Swift/Java/Kotlin) before reaching SQLite, adding performance overhead.
- May rely on the OS’s built-in SQLite version, leading to inconsistencies.
- Some bindings restrict parameter types, e.g., only allowing string parameters on Android.
- Often lack useful SQLite features such as:
  - Update hooks (for watching changes)
  - Commit hooks (less commonly used)
  – Low-level query optimizations (e.g., prepared statements)
  - Custom user-defined functions

#### Layer 3: High-level bindings
- Feature sets are highly inconsistent across libraries.
- Some libraries provide:
  - Transaction wrappers with proper locking mechanisms.
  - Asynchronous API support.
  - Connection pooling for concurrency.
  - Table change notifications for reactive updates.
  - Query builders.
  - Migrations.
  - Efficient batch updates.

## Mission

This manifesto seeks to:

1. Define the essential requirements for high-quality SQLite integrations.
2. Advocate for well-designed, maintainable, and performant SQLite libraries.
3. Provide guidance on selecting the best SQLite implementations for each language.
4. Encourage standardization and best practices in SQLite usage.

By addressing these challenges, we aim to make SQLite a more accessible and powerful choice for in-app databases across all platforms.

## Select a language or framework

<CardGroup cols={2}>
  <Card
    title="JavaScript"
    icon="js"
    href="https://localfirstnews.mintlify.app/recommended-libraries/javascript"
    target="_self"
  >
  </Card>
  <Card
    title="React Native"
    icon="react"
    href="https://localfirstnews.mintlify.app/recommended-libraries/react-native"
    target="_self"
  >
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card
    title="Flutter"
    icon="flutter"
    href="https://localfirstnews.mintlify.app/recommended-libraries/flutter"
    target="_self"
  >
  </Card>
  <Card
    title="Kotlin Multiplatform"
    icon="k"
    href="https://localfirstnews.mintlify.app/recommended-libraries/kotlin-multiplatform"
    target="_self"
  >
  </Card>
</CardGroup>

